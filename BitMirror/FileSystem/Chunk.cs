using System;
using System.IO;

namespace BitMirror
{
	/// <summary>
	/// A chunk contains a portion of the data contained within a file. The data
	/// is hashed to provide change tracking.
	/// </summary>
	public class Chunk
	{
		/// <summary>
		/// Ideal Chunk Size
		/// </summary>
		public const int TargetSize = 16194;

		/// <summary>
		/// Parent File
		/// </summary>
		private File mFile;

		/// <summary>
		/// Offset, in bytes, into the file where this chunk begins
		/// </summary>
		private long mOffset;

		/// <summary>
		/// Get the offset, in bytes, into the file where this chunk begins
		/// </summary>
		public long Offset
		{
			get { return mOffset; }
		}

		/// <summary>
		/// Length, in bytes, of this chunk
		/// </summary>
		private long mLength;

		/// <summary>
		/// Get the length of this Chunk in bytes
		/// </summary>
		public long Length
		{
			get { return mLength; }
		}

		/// <summary>
		/// Chunk Signature
		/// </summary>
		private byte[] mSignature;

		/// <summary>
		/// Chunk Signature. Generated by GenerateSignature
		/// </summary>
		/// <value>Chunk Signature</value>
		public byte[] Signature 
		{
			get { return mSignature; }
		}

		/// <summary>
		/// Hashing Object
		/// </summary>
		private Murmur3 mHasher = new Murmur3();

		/// <summary>
		/// Construct a chunk as a child of the given parent file
		/// </summary>
		/// <param name="file">Parent File</param>
		public Chunk( File file, long offset, long length )
		{
			mFile 	= file;
			mOffset = offset;
			mLength	= length;
		}

		/// <summary>
		/// Generate a new signature for this chunk from the given file stream and compare it to the
		/// stored chunk signature. If the two signatures are not equal, returns false to indicate 
		/// no match, otherwise returns true.
		/// </summary>
		/// <param name="stream">File Stream</param>
		public bool GenerateSignature( FileStream stream )
		{
			byte[] data = new byte[mLength];
			stream.Read( data, ( int ) mOffset, ( int ) mLength );

			byte[] signature = mHasher.ComputeHash( data );

			if( signature != mSignature )
			{
				return false;
			}

			return true;
		}

		/// <summary>
		/// Check whether this chunk is equal to the given chunk, based on its offset, length and signature.
		/// </summary>
		/// <param name="other">The <see cref="BitMirror.Chunk"/> to compare with the current <see cref="BitMirror.Chunk"/>.</param>
		/// <returns><c>true</c> if the specified <see cref="BitMirror.Chunk"/> is equal to the current <see cref="BitMirror.Chunk"/>;
		/// otherwise, <c>false</c>.</returns>
		public bool Equals( Chunk other )
		{
			if( other == null )
			{
				return false;
			}
				
			return other.mLength == mLength && other.mOffset == mOffset && other.mSignature.Equals( mSignature );
		}

		public override bool Equals( object obj )
		{
			Chunk other = obj as Chunk;

			if( other != null )
			{
				return Equals( other );
			}

			return base.Equals( obj );
		}
	}
}

